<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[百度搜索常用高级命令整理]]></title>
    <url>%2F2019%2F03%2F29%2Fbaidu-search-advanced%2F</url>
    <content type="text"><![CDATA[本文适用于在无法使用其他搜索引擎时，不得已的情况下使用百度搜索，通过一些搜索技巧来获得更准确的搜索结果。在可以访问外网时，个人不推荐使用百度搜索。 这仅整理了适用于百度搜索的常用命令，并不是全部的。 默认情况下，百度会根据输入框中的内容，结合搜索引擎的语义分析，进行关键词拆分，以求做到更准确的结果匹配。在两个关键词之间插入空格，可以在一定程度上提高匹配的准确度。但有些情况下，这可能与用户所期望的目标背道而驰。 完全匹配 “北京到上海的火车票” 为搜索的关键词加上英文双引号，百度就会认为双引号里的是一个完整的词，将不会再进行分词。搜索出来的结果会是形如 北京到上海的火车票xxx，而不是 北京 和 上海 的 火车 有几列。 《三体》 搜索书籍类时同样可以给关键词加上书名号，效果与双引号是一样的。 排除关键词 哪家医院好 -baijiahao 用法是在关键词的后面加上英文减号 - ，再加上要排除的关键词，注意减号前面有个空格，减号后面没有空格。比如上面这段就会在搜索出的结果中排除百家号的内容。 关键词组合 (北京 | 南京) 形如 (A | B) 这种，搜索结果会要么包含 A，要么包含 B。上面的搜索结果中肯定会包含 北京 或 南京 两个关键词之一。（类似正则表达式） 关键词在网页标题中 title: 手机intitle: 手机 限定网页标题中必须出现 手机 这个关键词。 关键词在网页链接中 inurl: twitter 限定网址中必须出现 twitter 这个关键词。 站内搜索 site:weibo.sina.cn 新闻 把搜索范围限定在这个站点中，类似站内搜索。如果输入主域名会搜索包括子域名在内的所有匹配结果，也可以单独搜索子域名。但搜索出的结果一般不如站点自己提供的搜索全，这取决于百度对该站点链接的索引。 限定文件格式 filetype:doc 材料工程论文 搜索文件时用的，可以限定搜索结果中的文件格式，百度文库常用。 组合使用以上的这些搜索命令都是可以组合使用的。比如想要搜索百度文库中的某个文件，可以这样： site:wenku.baidu.com filetype:pdf 论文书写格式 最后，如果无法使用这些搜索命令，同样可以访问 百度高级搜索 页面来实现同样的效果。]]></content>
      <tags>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绕过 Android 7.0+ 网络安全配置]]></title>
    <url>%2F2018%2F03%2F14%2Fnetwork-security-configuration-newer-than-android-n%2F</url>
    <content type="text"><![CDATA[在 Android 7.0 以上的系统中，Google 引入了一种名为网络安全配置（Network Security Configuration）的功能。据官方文档所说，这个功能可以让开发者在一个安全的声明性 XML 配置文件中自定义应用的网络安全设置，而无需修改应用代码。也可以针对特定域和特定应用配置这些设置。可以参考官方文档原文https://developer.android.google.cn/training/articles/security-config.html 当然这篇文章并不是介绍 Network Security Configuration 的具体用法的，本篇文章主要讲如何绕过这种在 Android 7.0+ 的默认行为。 如果了解过相关的知识，对于这个新增的功能，最直观的感觉可能就是，在运行着 Android 7.0 的手机上无法使用 Fiddler 或类似工具抓到 https 连接的包了。只有一些 https 的握手请求，无法查看到实际的数据，根本原因就是应用不再信任用户导入的 Fiddler 证书了。 想要研究如何绕过这项功能，就必须先了解如何正常使用。据官方文档描述，需要在 res/xml 下创建一个 XML 文件来自定义网络配置：下面给出几个样例，可参照注释 配置该应用的所有 HTTPS 链接123456789&lt;?xml version="1.0"encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config&gt; &lt;trust-anchors&gt; &lt;!-- 信任锚点集合 --&gt; &lt;certificates src="system"/&gt; &lt;!-- 信任系统自带的证书 --&gt; &lt;certificates src="user"/&gt; &lt;!-- 信任用户导入的证书 --&gt; &lt;/trust-anchors&gt; &lt;/base-config&gt;&lt;/network-security-config&gt; 配置该应用的自定义 CA12345678&lt;?xml version="1.0"encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;base-config&gt; &lt;trust-anchors&gt; &lt;certificates src="@raw/my_custom_ca"/&gt; &lt;!-- 放在 res/raw 下的自定义 CA 文件 --&gt; &lt;/trust-anchors&gt; &lt;/base-config&gt;&lt;/network-security-config&gt; 根据域名配置 HTTPS 可信域12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;domain-config&gt; &lt;!-- 与上文的 base-config 不同 --&gt; &lt;domain includeSubdomains="true"&gt;example1.iacn.me&lt;/domain&gt; &lt;!-- 过滤域名，可配置多个 --&gt; &lt;domain includeSubdomains="true"&gt;example2.iacn.me&lt;/domain&gt; &lt;!-- 一般会将 CDN 配置在此 --&gt; &lt;trust-anchors&gt; &lt;certificates src="system"/&gt; &lt;/trust-anchors&gt; &lt;/domain-config&gt;&lt;/network-security-config&gt; 开发阶段的配置仅在 android:debuggable=”true” 时生效 12345678&lt;?xml version="1.0"encoding="utf-8"?&gt;&lt;network-security-config&gt; &lt;debug-overrides&gt; &lt;trust-anchors&gt; &lt;certificates src="system"/&gt; &lt;/trust-anchors&gt; &lt;/debug-overrides&gt;&lt;/network-security-config&gt; 除此之外，还需要在 AndroidManifest.xml 中引用自定义的网络安全配置 1234567&lt;?xml version="1.0"encoding="utf-8"?&gt;&lt;manifest&gt; &lt;application android:networkSecurityConfig="@xml/network_security_config" ...&gt; &lt;/application&gt;&lt;/manifest&gt; 上面是 Network Security Configuration 的使用简介，那么如何绕过该功能呢？ 重编译 APK 文件如上文介绍，需要将目标 APK 文件反编译，然后修改 XML 配置文件，在 trust-anchors 中信任用户导入的证书，之后重新打包即可。 运行时 Hook在某些情况下，第一种方法也许是不可行的。比如说，需要保留目标应用原始的签名文件。这是无法做到的，因为你不可能拿到开发者的原始证书去给重编译后的应用签名。这里就需要用到 Hook 技术，可以在不修改应用代码的前提下修改应用的行为。 查看 Android 7.1.2_r36 源码，android.security.net.config.ManifestConfigSource 类 用于加载和处理网络安全配置 XML 文件的相关信息getConfigSource() 方法下，如果应用未配置网络信息，它将会加载默认配置 12345678910111213141516171819202122public final class NetworkSecurityConfig &#123; ... private ConfigSource getConfigSource() &#123; ... ConfigSource source; if (mConfigResourceId != 0) &#123; ... source = new XmlConfigSource(mContext, mConfigResourceId, debugBuild, mTargetSdkVersion, mTargetSandboxVesrsion); &#125; else &#123; ... source = new DefaultConfigSource(usesCleartextTraffic, mTargetSdkVersion, mTargetSandboxVesrsion); &#125; mConfigSource = source; return mConfigSource; &#125;&#125; DefaultConfigSource 类是 ManifestConfigSource 类中一个内部类，即上文代码中返回的默认网络配置。 1234567891011121314151617public final class NetworkSecurityConfig &#123; ... private static final class DefaultConfigSource implements ConfigSource &#123; ... public DefaultConfigSource(boolean usesCleartextTraffic, int targetSdkVersion, int targetSandboxVesrsion) &#123; mDefaultConfig = NetworkSecurityConfig.getDefaultBuilder(targetSdkVersion, targetSandboxVesrsion) .setCleartextTrafficPermitted(usesCleartextTraffic) .build(); &#125; &#125;&#125; 在其构造方法中，调用了 android.security.net.config.NetworkSecurityConfig 类中的 getDefaultBuilder() 去构造一个默认配置。 1234567891011121314151617181920public final class NetworkSecurityConfig &#123; ... public static final Builder getDefaultBuilder(int targetSdkVersion, int targetSandboxVesrsion) &#123; Builder builder = new Builder() .setHstsEnforced(DEFAULT_HSTS_ENFORCED) .addCertificatesEntryRef( new CertificatesEntryRef(SystemCertificateSource.getInstance(), false)); ... if (targetSdkVersion &lt;= Build.VERSION_CODES.M) &#123; builder.addCertificatesEntryRef( new CertificatesEntryRef(UserCertificateSource.getInstance(), false)); &#125; return builder; &#125;&#125; 可以看到，在应用的 targetSdkVersion &lt;= M 时（Android 6.0 及以下），有一个 addCertificatesEntryRef(UserCertificateSource)，系统将默认信任用户导入的证书。 那么以 Xposed 为例，Hook getDefaultBuilder()，在调用前将第一个参数 targetSdkVersion 改为 Android N 以下就可以了。这里给出核心代码： 1234567891011public void initZygote(StartupParam startupParam) throws Throwable &#123; Class&lt;?&gt; targetClass = findClass("android.security.net.config.NetworkSecurityConfig", null); if (targetClass != null) &#123; XposedBridge.hookAllMethods(targetClass, "getDefaultBuilder", new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; param.args[0] = Build.VERSION_CODES.M; &#125; &#125;); &#125;&#125; 添加系统 CA 证书在上文中可以发现，应用是会默认信任系统证书的。那么我们也可以将自己的 CA 文件添加至系统。从 Charles 里导出二进制格式证书，但要使 Android 能够识别，还需要做一些转换，我们可以很方便的使用 openssl 工具来做到。 这里以导出的 cert.cer 证书文件为例。 1$ openssl x509 -inform DER -subject_hash_old -in cert.cer 执行该命令，并复制输出结果的第一行哈希字符串，后面会用。如下图所示。 1$ openssl x509 -inform DER -text -in cert.cer -out 7ef3ba8a.0 以刚才复制的哈希字符串为文件名，.0 结尾，如 7ef3ba8a.0，当做输出的文件名。执行后就会输出 7ef3ba8a.0 这个文件。 复制输出的文件到 Android 上 /system/etc/security/cacerts/ 这个目录下，644 权限。然后重启手机，你的证书就被添加到系统里了。]]></content>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泉城公交开发手记（二） API分析]]></title>
    <url>%2F2018%2F01%2F16%2Fjinan-bus-note2%2F</url>
    <content type="text"><![CDATA[本文算是此系列的第一篇，我打算写写济南公交的服务端 API。当下的环境，基本每个应用都会具备联网请求数据的功能，公交客户端这种实时性很强的应用更是如此。既然我们打算做一个第三方客户端，那么第一步就是先要拿到各个车辆的实时数据。下面我会通过抓包来分析原版 369 出行的各个请求，关于抓包过程之前我也写过一篇文章介绍，这里就不多赘述了。 因为请求众多，这里只针对实际需要用到的数据进行说明，无用的类似请求广告图片什么的就不写了。 首次打开提示需要登录用户名，这部分其实是无用的。正常的流程会在用户登录时服务端返回一个 Token，后续请求会携带这个 Token。然而 369 出行的这个登录流程完全是无用的，登录的成功与否只是决定能不能进入下一个页面。还有一个值得吐槽的是整个登录流程用户名密码明文传输… 0. 参数说明向微步服务器的所有请求都需要在 Header 中加上 version 参数，值是版本号，示例version = android-insigma.waybook.jinan-2337，后面不再说明。 Json 返回的变量名，也是只说明一次的，后面重复的也不会再说明。 1. 首页GET –&gt; http://www.iwaybook.com/server-ue2/rest/servers-v2/370100 数据 说明 370100 济南市身份证号六位数字地址码 返回 12345678910111213&#123; "status": &#123; "code": 0 &#125;, "result": &#123; "id": 3, "name": "370100", "httpAddr": "60.216.101.229", "functions": "&#123;\"bus\":&#123;\"httpAddr\":\"60.216.101.229\",\"transfertype\":\"1\"&#125;&#125;", "state": 1, "useToken": false &#125;&#125; 变量 说明 httpAddr 下一步请求的服务器地址 GET –&gt; http://jinan.iwaybook.com/download/update.json 数据 说明 version 当前已安装的版本 返回 12345678910111213&#123; "status": &#123; "code": 0, "msg": "" &#125;, "result": &#123; "versionCode": 2337, "versionName": "3.3.7", "descriptions": ["1.增加了“车辆租赁”"], "must": false, "url": "http://60.216.101.229/download/jinan.apk" &#125;&#125; 变量 说明 versionCode 最新 versionCode versionName 最新 versionName descriptions 更新日志 must 如果为 true，会强制更新，不然无法进入。false 则不会 url 最新版本下载链接 2. 车辆搜索界面搜索界面的车辆相似查询 GET –&gt; http://60.216.101.229/server-ue2/rest/buslines/simple/370100/118/0/20 数据 说明 60.216.101.229 上文中请求获取到的 httpAddr，后续也是这个地址 118 路线编号 0 从第几个条目请求 20 请求多少个条目 返回 1234567891011121314151617181920212223242526&#123; "status": &#123; "code": 0, "msg": "" &#125;, "result": &#123; "pageParam": &#123; "offset": 0, "len": 20, "totalNum": 2 &#125;, "result": [&#123; "id": "223", "lineName": "118", "startStationName": "公交祝甸车场", "endStationName": "市立五院", "updateTime": "Sep 29, 2017 12:25:11 AM" &#125;, &#123; "id": "224", "lineName": "118", "startStationName": "市立五院", "endStationName": "公交祝甸车场", "updateTime": "Sep 29, 2017 12:25:31 AM" &#125;] &#125;&#125; 变量 说明 id 路线ID lineName 路线编号 startStationName 始发站 endStationName 终点站 updateTime 信息更新时间 这里需要注意同一路车的去程与返程是两个不同的 ID 3. 路线详情界面 GET –&gt; http://60.216.101.229/server-ue2/rest/buslines/370100/223 数据 说明 223 路线ID 返回 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; "status": &#123; "code": 0, "msg": "" &#125;, "result": &#123; "id": "223", "area": 370100, "lineName": "118", "startStationName": "公交祝甸车场", "endStationName": "市立五院", "stations": [ &#123; "id": "1", "area": 370100, "stationName": "公交祝甸车场", "lng": 117.09900257524, "lat": 36.703679321059, "buslines": "", "state": "0", "updateTime": "Sep 29, 2017 12:25:11 AM", "distance": 0, "busLineList": [] &#125;, &#123; "id": "2", "area": 370100, "stationName": "祝甸", "lng": 117.09818542729, "lat": 36.701505610837, "buslines": "", "state": "0", "updateTime": "Sep 29, 2017 12:25:11 AM", "distance": 0, "busLineList": [] &#125; ... ... ], "ticketPrice": "票价一元", "operationTime": "祝甸5:30－00:00 市立五院", "owner": "", "linePoints": "117.09900257524_36.703679321059,117.09818542729_36.701505610837,117.09402184523_36.701017213509,117.09066994065_36.700634744005...", "updateTime": "Sep 29, 2017 12:25:11 AM", "state": "0" &#125;&#125; 变量 说明 stations 是一个 List。该路线所有站点的信息 stationName 站点名 lng 经度坐标 lat 纬度坐标 state 站点状态。0 可用，1 不可用 ticketPrice 票价 linePoints 所有站点的坐标。以下划线_分隔经度和纬度 该路线的所有站点会在 stations 中体现，stations 的大小就是该路线所有站点的数量。这里的 lng, lat 经纬度属于百度 BD09 坐标，后面会详细说明。linePoints 是一些字符串，所有站点的坐标。实际没什么用处，因为上文的 stations 中已经包含各个站点的信息了。 GET –&gt; http://60.216.101.229/server-ue2/rest/buses/busline/370100/223 返回 1234567891011121314151617181920212223242526272829303132333435363738&#123; "status": &#123; "code": 0, "msg": "" &#125;, "result": [&#123; "busId": "4635", "lng": 116.973701, "lat": 36.66398, "velocity": 22.883572962605573, "isArrvLft": "2", "stationSeqNum": 23, "status": "1", "buslineId": "223", "actTime": "Jan 16, 2018 03:50:04 PM", "cardId": "4635", "orgName": "", "averageVelocity": 9.565269318966328, "coordinate": 0 &#125;, &#123; "busId": "4631", "lng": 116.957313, "lat": 36.654813, "velocity": 50.211262538794415, "isArrvLft": "2", "stationSeqNum": 27, "status": "1", "buslineId": "223", "actTime": "Jan 16, 2018 03:49:54 PM", "cardId": "4631", "orgName": "", "averageVelocity": 9.178488660594233, "coordinate": 0 &#125; ... ... ]&#125; 变量 说明 busId 车辆自编号 stationSeqNum 即将到达第多少个站 actTime 最后活动时间 cardId 报站器ID averageVelocity 平均时速 busId 是该车的自编号，由济南公交公司分配，方便管理stationSeqNum 即将到达第几个站，参见上文的 stations这里的 lng, lat 经纬度属于地球 WGS-84 坐标 可以看到这里使用的坐标系统和上文中的不同，这里就简略介绍一下这几种坐标的区别。 WGS-84 坐标系，是国际标准坐标系。从专业 GPS 设备中取出的数据遵循这种坐标，也是国际地图提供商所使用的坐标系。 GCJ-02 坐标系，也叫国测局坐标系，又称火星坐标。是由中国国家测绘局指定的一种大地坐标系。会对原始坐标进行算法加密，加入随机偏移，隐藏真实位置。理论上不可逆推。国测局规定国内出版的各种地图系统（包括电子形式），必须至少采用 GCJ-02 对地理位置进行首次加密。 BD-09 坐标系，是百度公司的加密算法坐标系，同样是一种偏移算法。该算法不公开。据传是从 GCJ-02 加密而来，也不一定，也许直接从 WGS-84 转换而来也不得而知 这三种坐标系的互相转换，网上也有流传方法，但并不完美。 3. 公告界面 GET –&gt; http://60.216.101.229/server-ue2/rest/busAnnouncements/370100/all/0/20 返回 1234567891011121314151617181920212223242526&#123; "status": &#123; "code": 0, "msg": "" &#125;, "result": &#123; "pageParam": &#123; "offset": 0, "len": 20, "totalNum": 238 &#125;, "result": [&#123; "id": "ab9f877a737f42688cd16d73065cd39f", "area": 370100, "title": "1月13日起,140路调整部分运行路段", "content": "受蓝翔路道路施工影响，1月13日起，140路调整部分运行路段。\n\n140路调整后沿蓝翔中路向东、东宇大街向南、粟山路向东再向南、小清河北路向东恢复原线，新设时代总部基地西门、东宇花园、粟山路东宇大街、东沙王庄、粟山路黄岗路、王炉庄北、粟山路永鼎路站点，将王炉庄站点迁移至粟山路路口东侧，撤销蓝翔中路中段、蓝翔路蓝翔中路、时代总部基地、卢庄工业园、蓝翔路粟山路、北辛庄北、北辛庄站点。", "publisher": "济南市公共交通总公司", "updateTime": "Jan 11, 2018 03:51:21 PM", "state": "1", "valid": 1 &#125; ... ... ] &#125;&#125; 变量 说明 totalNum 全部公告数量 title 标题 content 内容 publisher 发布人 updateTime 发布时间 valid 是否可用 有了这些必要的信息，已经可以开始做一个第三方的客户端了。下一篇文章，将会详细介绍自定义线路图 View 的实现。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泉城公交开发手记（一） 说明]]></title>
    <url>%2F2018%2F01%2F07%2Fjinan-bus-note1%2F</url>
    <content type="text"><![CDATA[泉城公交是我在 2015 年的时候开发的一个济南公交第三方客户端，基本实现了原生济南公交客户端的部分功能。但出于一些原因，不得不停止更新。我将所有源代码开源在了 GitHub。然后有网友邮件询问相关问题，所以，我整理了一下以前开发时的一些笔记，整理成几篇文章发出来。 这几篇文章大概分为以下几个部分API 分析、通知模块实现、自定义线路图 View 等等，还有部分填坑的说明。路线规划不会写，因为这部分整个就是调用的百度离线地图 SDK。 如果时间充裕的话，可能还会写一写济南公交（微步、369出行）新版的 NFC 公交卡充值实现。 本系列文章仅供技术交流，请勿用于商业及非法用途，如产生法律纠纷与作者无关。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Android Studio 动态调试 Smali 代码]]></title>
    <url>%2F2017%2F09%2F29%2Fusing-AS-debug-smali-code%2F</url>
    <content type="text"><![CDATA[0x1 准备一台可以正常运行 Android Studio / IDEA 的电脑一个顺手的 Smali 代码反编译工具smalidea 插件，可从 这里 获取，baksmali 工具也有你需要有一个目标 APK 文件，这里我新建的一个测试项目为例 0x2 开始 1234567891011121314151617public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void testClick(View view) &#123; // 方便测试，尽可能多用些中间变量 double radius = 15; double square = Math.pow(radius, 2); double area = Math.PI * square; Toast.makeText(this, String.valueOf(area), Toast.LENGTH_SHORT).show(); &#125;&#125; 打开 Android Studio，进入 File -&gt; Settings -&gt; Plugins，点击 Install plugin from disk 按钮，选择并安装 smalidea 插件 反编译源 apk 文件，生成 out 文件夹，然后从 Android Studio 的 File -&gt; New -&gt; Import Project，导入 out 文件夹，记得选择 Source Folder 成功导入后你就可以发现 Smali 代码的关键字已经可以高亮显示了 再次打开 Android Studio，点击 Run -&gt; Edit Configurations，新建 Remote 类型的调试器，如图 以调试模式在手机端或模拟器运行目标应用 adb shell am start -D -n me.iacn.testapplication/.MainActivity 此时目标应用会在打开时处于挂起状态，然后 adb shell ps 在其中找到以目标应用包名为 NAME 的一个进程，查看他的 PID adb forward tcp:6666 jdwp:5444 其中，forward 为刚才新建 Remote 调试器时所填的本地端口。jdwp 为在上面所查看的目标应用 PID。此种方式实际上是利用 Remote 调试器，通过本地端口 6666 连接手机调试目标应用 此时回到 Android Studio，下一个断点，然后 Run -&gt; debug Unnameed，稍等一会儿，就可以从 Debugger 面板里查看调试结果了 需要注意的是，有时寄存器的值不会直接在 Variables 面板里显示出来，需要将想要查看的变量添加到 Watch 中，然后在 Watch 面板中查看]]></content>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下 nc 命令的简单介绍]]></title>
    <url>%2F2017%2F08%2F16%2Flinux-netcat%2F</url>
    <content type="text"><![CDATA[nc 是 Linux 下的一个强大的命令。nc 是简称，全名是 netcat。大部分的 Linux 发行版都有自带 nc 这个命令，如果没有的话就需要自己安装了 我这里使用的是 CentOS 7.3，对于 nc，你可以使用 yum 安装或者自己编译二进制文件。这里推荐使用 yum 安装，因为 yum 可以自动解决依赖问题 1yum install nmap-ncat.x86_64 同样，netcat 也有 Windows 版本可用，你可以在 https://eternallybored.org/misc/netcat 这里下载到 netcat 的 Windows 版本。这里下载到的是一个压缩包，里面包含 netcat 的源代码和 nc &amp; nc64 两个已经编译好的二进制文件，你可以根据自己系统来选择使用 nc 或 nc64 成功安装之后你就可以使用 nc 命令了，使用 nc –help，你可以查看到 nc 命令的详细帮助。我在这里使用几个具体的例子来简要概述下 nc 命令的基本使用方法 0. nc 命令的标准使用形式1nc [-options] ip port[s] [ports] ip 处是可以使用域名的，nc 会调用 DNS 解析成 IP 地址。如果不需要 nc 自动解析的话可以在执行时添加 -n [–nodns] 参数 1. 两台主机之间发送实时消息12A 主机：nc -lp portB 主机：nc ip port -l [–listen]：绑定并监听传入的连接-p [–source-port]：指定要使用的源端口 建立连接后在任意一台主机输入信息并按下回车发送后对方就能收到因为 nc 是会自动从标准流中读取数据的，如果想要禁止，可以在命令执行时使用 -d 参数 2. 两台主机之间传送文件12接收端：nc -lp port &gt; outputfile发送端：nc destip port &lt; inputfile 这一条本质和上面那个是一样的，只是借用了输出重定向这个特性。同样，nc 命令也支持管道，你甚至可以借由此实现克隆分区： 1234567接收端：unmount /dev/sda2nc -lp port | dd of=/dev/sda2发送端：unmount /dev/sda1dd if=/dev/sda1 | nc destip port 3. 发送 HTTP 请求123456789$nc destip 80 &lt;&lt;EOFGET /HTTP/1.1Cookie:xxxxxx:xxxxxxEOF 为什么？因为 nc 发送的是纯文本保存 Web 页面？重定向输出流就好了 4. 反向代理 Shell12发送端：nc -lp localport执行端：nc -t -e C:/windows/system32/cmd.exe destip destport -t [–telnet]：响应 telnet 交互-e [–exec-command]：执行给定的命令，也可以携带一个 lua 脚本 destip 和 destport 即为发送端的 IP 和 localport连接成功后，发送端的会得到一个执行端的 Shell 你可以使用 -w 来设置无响应时的超时时间 nc 在默认情况下，如果连接到 Server 的 Client 断开连接，那么 Server 也会跟着退出。你可以使用 -k 参数来保持 Server 的监听状态 nc 是支持 IPV6 的，你可以使用 -4 &amp; -6 参数来指定使用 IPV4 或 IPV6 nc 默认是使用 TCP 协议通信，但是也支持 UDP，可添加 -u 参数来使用 UDP 协议 对于使用 nc 去扫描端口这个用途，我是不推荐的，因为 nc 的扫描速度十分之慢。而且，在最新的 nc 中，已经去掉了 -z &nbsp;&nbsp;&nbsp;(zero-I/O mode [used for scanning]) 这个参数。所以，对于这个需求，还是使用更专业的 nmap 吧]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vShere Client 无法连接 vCenter 故障排查思路]]></title>
    <url>%2F2017%2F07%2F14%2Fvsphere-server-problem-check%2F</url>
    <content type="text"><![CDATA[问题如图所示，vSphere Client 弹框无法连接到 vCenter，只提示出现未知错误 这类问题一般不好排查，因为没有给出错误的具体信息，错误提示或者错误代码。我这里结合实例，总结一下该类问题的排查思路 1. 检查网络连接情况；检查 vCenter 的 IP，用户名，密码是否正确 这个在大多数出现在实验环境中，生产环境中一般不会出现这种错误解决办法也没什么好说的，ping 检查连接，用户名密码换成正确的 2. 检查 vCenter 的 Web Client 能否正常访问 vCenter 是可以从 Web 端访问管理的URL 是：https://client-hostname:port/vsphere-client默认情况下此端口为 9443，但可在 vSphere Web Client 安装过程中更改此端口 这里打开并输入正确的用户名密码，发现可以正常访问，说明 vCenter 整个本身是没有什么问题的 3. 检查 VMware VirtualCenter Server 服务是否已经启动 VMware VirtualCenter Server 是 vCenter 的核心服务，无法连接的原因大部分是因为这个服务没有启动使用 远程桌面 连接到 vCenter 所在的虚拟机，打开 服务器管理器 - 诊断 - 服务，找到这个服务，检查其状态 我所在的环境是一个 vCenter 虚拟机通过 Platform Services Controller 去管理多个安装了 VMWare ESXi 底机。由于所在环境出于安全起见，在 vCenter Server 安装时禁止了 vCenter 虚拟机的远程桌面权限，所以这里采用另一种方式跳转上去 由于 VMWare ESXi 底机是允许通过 vSphere Client 连接去管理单个的实体服务器的，而这种方式不需要依赖 VMware VirtualCenter Server 服务。所以我这里先连接 vCenter 虚拟机所在的那台实体服务器，再在其中打开控制台 打开后检查，发现这个服务确实是没有正常启动 4. VMware VirtualCenter Server 服务无法正常启动 一般来说，若是该服务没有启动，手动启用后便可恢复正常。但有些情况下无法手动启动，这时候就要结合具体情况来分析了vCenter Server 的正常运行是需要依赖数据库的，所以先应该检查数据库的相关服务有没有正常运行vCenter Server 在安装时是会将其核心服务设置为开机自启的。所以，如果在其启动时数据库服务没有正常运行，就会出现问题。我习惯的做法是将数据库相关服务的启动类型设置为 自动，而把 vCenter Server 相关服务设置为 自动（延迟启动），来保证数据库服务优于 vCenter Server 服务启动。 5. VMware VirtualCenter Server 服务正常启动了还是不能连接 通常情况下，vCenter Server，vCenter 依赖的数据库和其他业务服务都是分开机器安装的，但也有安装在一台虚拟机中的情况因为 vCenter Server 需要使用 80 端口，所以保证该端口的正常通信是必要的。可以使用 telnet 命令来检查端口是否已经开启，例如 telnet 10.100.100.14 80。如果不通，就要检查各防火墙的出入栈规则了另外 Web 服务也会占用 80 端口来进行通信，这个也要仔细甄别 关于 vCenter 服务的相关问题实在太多，这里只是整理了一些思路来帮助检查对于这种问题没有什么好办法，就是查看日志来找问题原因。]]></content>
      <tags>
        <tag>网络</tag>
        <tag>vSphere</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 6.0 上的双卡相关开发]]></title>
    <url>%2F2017%2F06%2F07%2Fmultisim-for-android-6-0%2F</url>
    <content type="text"><![CDATA[在 Android 5.0 以前，各芯片厂商上的双卡开发没有一个统一的标准，以至于做起双卡适配来十分麻烦。Android 5.0 之后，Google 官方统一了双卡平台的适配，并在 Framework 中添加了双卡相关的 API，这对于需要处理双卡的应用来说提供了很大的便利。 因为 Android 5 上的双卡 API 还不是很完善所以本文是介绍在 Android 6.0 平台上的双卡相关开发后续还会有一篇文章来介绍在双卡处理 Android N 上的实现 言归正题在 API 层面上，自 Android 5.0 开始，加入了 SubscriptionManager。双卡相关的处理主要是依赖这个 API，你可以通过 Context 类里面的 getSystemService 方法和 SubscriptionManager.from(Context) 来取得它的对象，当然它内部也是调用的 getSystemService。 在数据库方面，TelephonyProvider 的 telephony.db 中新增了 siminfo 表来管理双卡的信息 由于字段太多，我这里只截图了几个关键的字段需要注意的是 _id 和 sim_id 这两个字段_id: 这个不用多说，系统要求，自增长，从 0 开始sim_id：该行的卡所在的卡槽值，有 0，1，-1 三个值| 数值 | 描述 || :–: |:—————————:|| 0 | 该卡插在卡槽 1 中（主卡槽） || 1 | 该卡插在卡槽 2 中（副卡槽） || -1 | 手机内曾经插入过该卡 |Ps. 在 Android 6.0+，-1 值已经被移除 每插入一张新的 SIM 卡，siminfo 表中就会插入一行新的数据，然后 _id 会自增长加 1 详细的各个 API 可以去查阅 API 文档。我这里仅以获取双卡手机两个卡的 IMSI 为例，介绍一下各平台所使用的方法SubId 这个值对于双卡相关的操作来说是必要的 Android 6.0： 1234567891011// 返回当前手机所插入 SIM 卡的个数TelePhonyManager.getPhoneCount()SubscriptionManager subManager = SubscriptionManager.from(this);// 这个方法传进手机的卡槽序号，返回对应所插 SIM 卡的信息SubscriptionInfo info = subManager.getActiveSubscriptionInfoForSimSlotIndex(1);int subId = info.getSubscriptionId();// 该方法在 Android 6.0 中还是 @hide 状态，可以反射调用TelephonyManager teleManager = getSystemService(TelephonyManager.class);String imsi = teleManager.getSubscriberId(subId); MTK： 12345678910111213141516171819try &#123; TelephonyManager teleManager = getSystemService(TelephonyManager.class); Class&lt;?&gt; phoneClass = Class.forName("com.android.internal.telephony.Phone"); Field gemni1Field = phoneClass.getField("GEMINI_SIM_1"); Field gemni2Field = phoneClass.getField("GEMINI_SIM_2"); gemni1Field.setAccessible(true); gemni2Field.setAccessible(true); int simId1 = (int) gemni1Field.get(null); int simId2 = (int) gemni2Field.get(null); Method method = TelephonyManager.class.getDeclaredMethod("getSubscriberIdGemini", int.class); String imsi1 = (String) method.invoke(teleManager, simId1); String imsi2 = (String) method.invoke(teleManager, simId2);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 高通： 1234567891011121314try &#123; Class&lt;?&gt; msmTeleManager = Class.forName("android.telephony.MSimTelephonyManager"); Method method = msmTeleManager.getMethod("getSubscriberId", int.class); int simId1 = 0; int simId2 = 1; Object phoneMsim = getSystemService("phone_msim"); String imsi1 = (String) method.invoke(phoneMsim, simId1); String imsi2 = (String) method.invoke(phoneMsim, simId2);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 对比三种获取双卡 IMSI 的方式，可以看出 Android 原生支持的双卡 API 更加的规范标准。目前新出的 Android 5+ 的新机上基本都采用了原生 API，Android 的碎片化又缩小了一步]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决 Xshell SSH 连接 Linux 中文乱码]]></title>
    <url>%2F2017%2F04%2F29%2Fxshell-ssh-chinaese-utf8%2F</url>
    <content type="text"><![CDATA[0x0首先需要确保你的 Xshell 的连接编码是 UTF-8。虽然可以修改 Linux 端的字符集去迎合 Windows 端做到中文的正常显示，但在当前 I18N 的大环境下，还是尽量用 UTF-8 吧。 打开 Xshell 的会话属性窗口，在左边选择到 终端，编码一项内，如果不是 Unicode 的话请改成 Unicode 0x2不出意外的话，重新连接你的 SSH 应该已经能正常显示中文了，因为大部分 Linux 的默认连接编码就是 UTF-8 的。 如果还是不能正常显示，你需要这样做修改 /etc/profile 这个文件在其中添加 1export LC_ALL="zh_CN.UTF-8" 这条命令的意思是设置 Locale 为 UTF-8，会在用户初始化时执行 重启系统，这里中文已经能正常显示了]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 + Python Flask + MySQL + Nginx 配置]]></title>
    <url>%2F2017%2F04%2F14%2Fcentos-python-flask-nginx%2F</url>
    <content type="text"><![CDATA[不是很常用，算是给自己留个记录吧部分资料参考自网络 0.切换到 root 用户 1sudo su 1.安装并启动 Nginx 123yum install nginxsystemctl start nginx.service # 开启 nginx 服务systemctl enable nginx.service # 跟随系统启动 此时使用 localhost 应该会出现 Welcome to nginx 的欢迎页面了 2.安装并启动 MySQL（这里我用的是 MariaDB，就是 MySQL 换个壳，没多大区别…） 123yum install mariadb-server mariadbsystemctl start mariadb # 开启 mysql 服务systemctl enable mariadb # 跟随系统启动 3.初始化 MySQL 安全策略 1mysql_secure_installation 会提示输入 root 密码，默认为空，直接回车即可然后就问是否重新设置 root 密码，当然是要重新设置的啦。设置完后还有几个问题都输入 y 同意就行了 4.安装并配置 Python 和 pip 1yum install python34 # 安装 3.4.x 版本 由于 CentOS 自带了 Python 2.7 的版本，所以某些情况下，直接替换掉原始的版本可能出现未知问题，比如 yum 没法用之类的，就需要手动去 /usr/bin/python 修改链接关系，使其正确链接到 Python2，可用 ls -l 命令检查，这里我上一张正确的连接图后面执行命令的时候我将会用 Python3 来执行，python3 xxx 5.安装 pip，Gunicorn 和 flask 123yum install python34-pip # 安装 pippip3 install flaskpip3 install gunicorn 6.配置 Flask编写文件 /home/web/api/api.py 123456789101112from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello World!'if __name__ == '__main__': app.run() 7.使用 Gunicorn 启动项目 12345678910111213gunicorn -D -w 3 -b 127.0.0.1:8000 api:app注意要在项目根目录下执行这条命令-D 后台运行 -w 启动 3 个工作线程-b 指定 IP 和端口号最后的那个 api:appapi 就是那个 Python 文件的名称（不包括后缀/模块名）app 就是 Flask 实例的名称可参见上文 api.py 的代码 可以使用 ps -aux 命令查看系统运行的进程同样，你也可以使用 kill [PID] 来关闭 Gunicorn 的进程 8.配置 Nginx主要就是配置 nginx 目录，这里我以 api 为例 1vim /etc/nginx/conf.d/api.conf 12345678910server &#123; listen 80; server_name api.iacn.me; # 外部域名 location / &#123; proxy_pass http://127.0.0.1:8000; # 反向代理 Gunicorn 本地的服务地址 proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 保存好然后重启 Nginx 1systemctl restart nginx 9.可以查看一下端口信息 10.已经可以从外部访问了]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射获取类所实现接口的泛型实际值]]></title>
    <url>%2F2017%2F03%2F28%2Fjava-interface-generic-value%2F</url>
    <content type="text"><![CDATA[1.有三个类 TestClass （Main 方法所在类）TempClass （测试用的类）TempClass$InnerClass （测试用 TempClass 的内部类） 2.三个类的代码如下 123456public class TestClass &#123; public static void main(String[] args) &#123; // TODO:实现过程一会在这儿写 &#125;&#125; 1234567891011public class TempClass &#123; // 随便找了个需要泛型的接口实现了2333 class InnerClass implements Comparable&lt;String&gt; &#123; @Override public int compareTo(String o) &#123; return 0; &#125; &#125;&#125; 3.实现过程首先，获取 TempClass 的内部类 InnerClass 12Class&lt;?&gt;[] classes = TempClass.class.getDeclaringClass();Class&lt;?&gt; innerClass = classes[0]; API 简介（Class）： getClasses() ：获取该类的 public 内部类getDeclaredClasses() ：获取该类的所有内部类 然后，获取这个内部类所实现的接口 12Type[] types = innerClass.getGenericInterfaces();ParameterizedType type = (ParameterizedType) types[0]; API 简介（Class）： getGenericSuperclass() ：获取该类 Type 类型的父类getGenericInterfaces() ：获取该类所实现的 Type 类型的接口数组 之后，强转为 ParameterizedType 类型，调用其中的 getActualTypeArguments() 方法，该方法也是返回一个 Type 类型的数组，分别存储的是具体的运行时泛型类型。这里取第一个，强转为 Class 就是实际的值了。 最后，全部代码放上 12345678910111213public static void main(String[] args) &#123; // TODO:实现过程一会在这儿写 Class&lt;?&gt;[] classes = TempClass.class.getDeclaredClasses(); Class&lt;?&gt; innerClass = classes[0]; Type[] types = innerClass.getGenericInterfaces(); ParameterizedType type = (ParameterizedType) types[0]; Class&lt;?&gt; clazz = (Class&lt;?&gt;) type.getActualTypeArguments()[0]; System.out.println(clazz); &#125; 运行结果]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 删除多余的网络配置项]]></title>
    <url>%2F2017%2F03%2F24%2Fwin10-delete-network-config%2F</url>
    <content type="text"><![CDATA[1.Win + R 运行，输入 regedit，打开注册表编辑器2.找到下面两个键 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\NetworkList\Profiles HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\NetworkList\Signatures\Unmanaged 3.在这两个键的下面有一堆 Hash 值命名的目录 不需要哪个删除就是了 可以根据目录里面 ProfileName 的值来判断这个目录是属于哪个网络配置的 同样，如果需要修改网络配置的名字，也可以从这里修改 ProfileName 的值 修改注册表有一定风险，请一定要仔细]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 USB-To-Console 串口驱动 (x86 x64)]]></title>
    <url>%2F2017%2F02%2F28%2Fwin10-usb-to-console%2F</url>
    <content type="text"><![CDATA[最近将 Win10 更新到 14393，之前的 USB 转串口线一插上就蓝屏重启，费了好多功夫 Google 到了之前版本的驱动，试了试居然没事了，这里就分享下吧 下载地址：百度网盘 Step1. 进入 Step1 文件夹，安装 Setup.exe。如果成功，则无需进行第二步了。 Step2. 进入 Step2 文件夹，安装 CH341SER.EXE。不行的话再安装 HL-340.EXE。 Windows10 专业版 x64 测试通过。]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles 抓包 Android 端 https]]></title>
    <url>%2F2017%2F02%2F21%2Fcharles-https%2F</url>
    <content type="text"><![CDATA[在阅读本文前，你应该已经会使用 Charles 进行 http 抓包。如果不会，请先掌握 http 抓包后再阅读本文 首先需要安装 Charles 的证书到手机端点击下图位置的 Save Charles Root Certificate 将会把证书文件导出，你需要选择一个导出位置 导出后将其移动到手机的内置存储，然后在 设置 - 安全 - 从存储设备安装 安装该证书（我的手机是 Android 原生 6.0 的 ROM，个别手机的位置可能不同） 需要注意的是，在安装时弹出的提示框中 凭据用途 一项，应该选择 WLAN 之后在 PC 端 Charles 的 SSL Proxying Settings 里 添加你想要抓包的链接的主机名 重新发起连接后，发现之前显示小锁图标的 https 请求已经可以正常抓取了 Ps.关于抓包中抓到的 connect 请求connect 是为了建立 http tunnel 而存在的。connect 是 http 众多方法中的其中一种，它跟 post、get、put、options 方法是并列的。但是它的使用场景很特殊，只有在受限制的网络环境中（防火墙、NAT、代理器）并且是 https 通信时，客户端会使用 http connect 请求代理服务器，代理服务器使用 connect 方法与目标服务器建立 http tunnel。通道建立后，客户端与服务器进行通信，代理服务器就像透明一样，只是接收、转发 tcp stream这个引用自 http://blog.csdn.net/wangjun5159/article/details/54142016，详细的可以查看原文]]></content>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 多主题之 EditText]]></title>
    <url>%2F2017%2F02%2F14%2Fmodify-edittext-color%2F</url>
    <content type="text"><![CDATA[多主题的需求在很多 Android 应用中都有存在，实现方式也是多种多样。有以插件化方式实现的，也有以修改原生控件颜色的方式实现的。本文所写的就是以修改原生控件颜色的方式应用主题的，EditText 的修改。 然而，这个不是这么好做的。。QAQ首先查阅 EditText 的 API 文档，发现还是提供了两个方法的 使用 EditText.setBackgroundTintList(colorStateList) 可以设置 EditText 下划线的颜色 使用 EditText.setHighlightColor(color) 可以设置 EditText 选中文字后的高亮颜色 恩，改完后确实生效了 但是。。输入光标和光标控制滑块还是原来的颜色，反而不伦不类的了。。 于是查看 EditText 的源码，发现是在它的父类 —— TextView 中的 mEditor 这个对象中控制的，但是这个变量是 private 的，也没有提供公开的获得方法，无奈只好用反射了 1234567private static Field mEditor;private static void getEditorFieldFromReflect() &#123; if (mEditor == null) &#123; mEditor = ReflectUtils.getDeclaredField(TextView.class, "mEditor"); &#125;&#125; 为了让反射达到最大的性能，声明了一个静态属性 mEditor，并在它为 null 的时候才进行反射（下同） ReflectUtils 是一个自定义的反射工具类 再获取输入光标的 Field 对象 1234567private static Field mCursorDrawableRes;private static void getCursorFieldFromReflect() &#123; if (mCursorDrawableRes == null) &#123; mCursorDrawableRes = ReflectUtils.getDeclaredField(TextView.class, "mCursorDrawableRes"); &#125;&#125; 这样就获取了输入光标的原始 id，也就是 mCursorDrawableRes由于原始的 CursorDrawable，是存在于 Android Framework 中的 framework-res.apk 中的，所以这里用一种曲线救国的方式，先获取到他的 id，进而获取到 Drawable，然后通过 Android 5.0 新增的 Tint 方式渲染 Drawable 的颜色，再设置进去 实现代码如下 1234567891011private static void setCursorColor(EditText editText, int color, Object editor) throws Exception &#123; int cursorId = mCursorDrawableRes.getInt(editText); Drawable drawable = editText.getContext().getDrawable(cursorId); if (drawable != null) &#123; drawable.setTint(color); &#125; ReflectUtils.setObjectField(mEditor.getType(), "mCursorDrawable", editor, new Drawable[]&#123;drawable, drawable&#125;); &#125; 这样输入光标的颜色就修改完成了 之后就是光标控制滑块的颜色了查看源码，发现这个对应的是三个 Drawable 只是这些的 id 是在 EditText 里的。于是，故技重施，和 mCursorDrawableRes 一样 12345678910 private static void getSelectFieldFromReflect() &#123; if (mSelectHandleLeft == null || mSelectHandleRight == null || mSelectHandleCenter == null) &#123; Class&lt;?&gt; EditorClass = mEditor.getType(); mSelectHandleLeft = ReflectUtils.getDeclaredField(EditorClass, "mSelectHandleLeft"); mSelectHandleRight = ReflectUtils.getDeclaredField(EditorClass, "mSelectHandleRight"); mSelectHandleCenter = ReflectUtils.getDeclaredField(EditorClass, "mSelectHandleCenter"); &#125;&#125; 123456789private static void setSelectHandleColor(EditText editText, int color, Object editor) throws Exception &#123; Drawable leftDrawable = (Drawable) mSelectHandleLeft.get(editor); Drawable rightDrawable = (Drawable) mSelectHandleRight.get(editor); Drawable centerDrawable = (Drawable) mSelectHandleCenter.get(editor); updateSelectHandleColor(leftDrawable, "mTextSelectHandleLeftRes", editText, color); updateSelectHandleColor(rightDrawable, "mTextSelectHandleRightRes", editText, color); updateSelectHandleColor(centerDrawable, "mTextSelectHandleRes", editText, color);&#125; 最后做个 setColor 的封装 1234567891011121314151617public static void setColor(EditText editText, int color) &#123; setUnderlineColor(editText, color); setHighlightColor(editText, color); try &#123; getEditorFieldFromReflect(); getCursorFieldFromReflect(); getSelectFieldFromReflect(); Object editor = mEditor.get(editText); setCursorColor(editText, color, editor); setSelectHandleColor(editText, color, editor); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 需要时直接 EditColorHelper.setColor(EditText, Color) 就可以了]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为交换机 SNMP 协议配置]]></title>
    <url>%2F2017%2F02%2F01%2Fhuawei-switch-snmp-config%2F</url>
    <content type="text"><![CDATA[SNMP 协议介绍：Simple Network Management 简单网络管理协议，是由 IETF 互联网工程任务组定义的一套网络管理协议。该协议基于简单网关监视协议，最初面向基于 IP 的网络管理所设计。利用 SNMP，一个管理工作站可以远程管理所有支持这种协议的网络设备，包括监视网络状态、修改网络设备配置、接收网络事件警告等 上面的这些定义都没什么用，简单说，SNMP 就是方便远程管理网络设备，不用维护人员到处跑的东西 在华为交换机上最简单的配置方式： 1.执行 1snmp-agent community read xxx 这个是设置一个 SNMP 的 Community，使用该 Community 连接交换机时，只可以读取该交换机的配置，不可写入。对应的可以把命令中的 read 换成 write，这样远程就可以通过 SNMP 协议去修改交换机配置了 2.再次执行 1snmp-agent sys-info version all 这个是设置该交换机支持的 SNMP 协议版本，一般有 V1, V2C, V3 这几个版本，最好设置成 all，这样就支持所有版本了，如果不设置这个，某些软件可能无法正常读取信息 3.这样一般就可以了]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 环境变量的设置是否需要重启]]></title>
    <url>%2F2016%2F12%2F25%2Fwindows-set-env-variable%2F</url>
    <content type="text"><![CDATA[最近从 Android Studio 导入一个项目，提示需要配置一个叫 ANDROID_SDK_HOME 的环境变量，然而 Google 的提示是建议我配置完之后重启，但是我实测配置之后没有重启也生效了，这是怎么回事呢？ 原来，环境变量就是属于 Windows 系统的一些预定义好的变量，其中分为用户变量和系统变量。用户变量只对当前设置环境变量的这个用户生效，系统变量则对整个系统生效。这些变量在用户登录时被设置，应用到系统里，对系统里运行的每一个程序都生效。 在一个程序启动的时候，它所可以读取的环境变量就会被复制到它所在的环境中。也就是说，每个程序在运行时都会拥有原始环境变量的一份复制体，不会受其他程序的影响。 所以结果就是，只要重新运行该程序，程序就会重新读取系统的环境变量，环境变量也就发生改变了。而如果修改的是系统要使用的环境变量，也就必须重启系统了。]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个团队里的 5 种人]]></title>
    <url>%2F2016%2F12%2F17%2Ffive-men-in-the-team%2F</url>
    <content type="text"><![CDATA[一个团队里，人分为 5 种人渣、人员、人手、人才、人物 人渣就是牢骚抱怨，无事生非，拉帮结派，挑起事端、吃里扒外的破坏分子 人员就是只领工资不爱做事，安排与自己无关的工作不愿干，属庸人之列 人手就是安排什么做什么，不安排绝对不做，等着下命令的人 人才就是每天发自内心做事，做事有责任、有思路、有条理，知道公司的事做好了，受益的是自己，同时真心为公司操心的人 人物就是全身心投入，用灵魂去思考、做事，决心要和老板做一番事业的人 人员斤斤计较，人手需要引导，人才关注当下，人物放眼未来！ 发展靠人才，做大靠人物！ 通常人渣有可能鱼目混珠地苟存在大团队、大机构中，小团队里很容易一眼就看到，没法混。而人员、人手、人才是主体，人物可遇不可求 任何团队都必须同心协力才能共赢发展，彼此促进，水涨船高]]></content>
      <tags>
        <tag>闲聊</tag>
        <tag>转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合并两个 Git 仓库]]></title>
    <url>%2F2016%2F11%2F16%2Fmerge-git-repo%2F</url>
    <content type="text"><![CDATA[本应在 /Project 下的 Git 根目录成了 /Project/app … 12345678.└── Project ├── app │ ├── xxx6.txt │ ├── xxx7.txt │ └── xxx8.txt ├── xxx1.txt └── xxx2.txt 就是这个样子，Git 的根目录成了 /app ，而需要的是 /Project ，但是 app 又是 Project 的子目录，想迁移过去又不想丢失 Commit 数据… 简单点说就是有 2 个 Git 仓库：repo1 和 repo2repo1 是 repo2 的子目录想要把 repo1 中的文件移入 repo2repo1 的 Commit 记录要保留 当前文件结构如下 12345.└── repo2 ├── repo1 ==============&gt; Git 仓库 │ └── repo1.txt └── repo2.txt 想要的结果是 12345.└── repo2 ==============&gt; Git 仓库 ├── repo1 │ └── repo1.txt └── repo2.txt 开始 新建 repo1 子目录，将原 /repo1 的文件移动至 /repo1/repo1 cd repo1mkdir repo1find -maxdepth 1 -not -name . -not -name repo1 -not -name .git -exec mv {} ./repo1 ; 目录结构变成 12345.├── repo1│ └── repo1│ └── repo1.txt└── repo2.txt 在 repo1 Git 提交刚才的操作 在 repo2 中 将 repo1 作为远程仓库，添加进来，设置别名为 temp cd ../repo2git remote add temp ../repo1/ 从 repo1 中抓取数据到当前 repo2 仓库 git fetch temp 将 repo1 中抓来的 master 分支作为新分支 checkout 到本地，新分支名命名为 repo1 git checkout -b repo1 temp/master 切换回 repo2 的 master 分支，并将 repo1 分支合并到 master git checkout mastergit merge repo1 删除 repo1 分支和远程地址 temp git branch -d repo1git remote remove temp 这样就可以了。大致思路就是伪造远程 repo1 仓库为 repo2 的一个分支，然后合并进来]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改 Git 已提交的用户名和邮箱]]></title>
    <url>%2F2016%2F11%2F10%2Fmodify-git-submitted-commit%2F</url>
    <content type="text"><![CDATA[有些时候，可能你在 Git 提交的时候不经意间提交了错误的 Commit 作者信息，那么如何修改成正确的呢？ 如果尝试修改 Git 的提交邮箱 git config –global user.name “Your Name”git config –global user.email “Your Email” 这样可以修改作者的名字和邮箱 但是这种方法只对之后的 Commit 有效，之前提交过的就改不了了… 还好，Google 到了一种解决办法，这里分享下，也算是做个记录 打开终端（Linux 的终端或 Windows 下 Git 客户端的 git-bash.exe 均可） 同步下来你的项目并进入目录（以 repo.git 为例） git clone –bare https://github.com/user/repo.gitcd repo.git 复制下面的脚本，可以直接复制到终端命令行里或新建 Shell 脚本并修改 oldEmail, newName, newEmail 三个变量为你自己的 12345678910111213141516171819#!/bin/bashgit filter-branch --env-filter 'oldEmail="Your Old Email"newName="Your New Name"newEmail="Your New Email"if [ "$GIT_COMMITTER_EMAIL" = "$oldEmail" ]; then export GIT_COMMITTER_NAME="$newName" export GIT_COMMITTER_EMAIL="$newEmail"fiif [ "$GIT_AUTHOR_EMAIL" = "$oldEmail" ]; then export GIT_AUTHOR_NAME="$newName" export GIT_AUTHOR_EMAIL="$newEmail"fi' --tag-name-filter cat -- --branches --tags 执行脚本，看到一堆 rewritten 的时候就说明写入完成了 git log 查看新的 Commit 信息是否正确 提交 git push –force –tags origin ‘refs/heads/*’ 删除临时文件 cd ..rm -rf repo.git 需要注意的是，上面的执行后，新 clone 出来的项目 Log 中 Name 和 Email 已经为最新的信息。在执行上面的几步之前已经 clone 出来的项目中，如果执行 git pull 的话，Log 中的 Name 和 Email 信息还是原来的信息 这样就算是完成了]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
